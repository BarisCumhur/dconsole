Функторы с автоматической проверкой параметров и немного больше...
------------------------------------------------------------------

Возникла у нас на работе задача написать консольку для дебажных нужд ( а-ля как в анриал/квейк и т. п.).
Код этот потом я немного переделал, выделил в отдельный маленький проекти сделал доступным для общественности вот по этой ссылке.
Консолька может быть с легкостью интегрирована в ваше приложение (я написал примеры интеграции для OpenGL, DirectX и просто тексттового режима)

А в данной статье расскажу немного о внутреннем устройстве комманд.

Немного поразмыслив, я решил, что это нехорошо - вешать на человека, который будет писать команды для этой консоли, 
также задачи по разгребанию параметров. Хотелось-бы, чтобы все, что нужно было указать - это С/С++ ф-ю, которая выполняется по данной команде.
Например, нужно написать ф-ю для добавления дебажного объекта. Выглядеть в консоли это должно быть примерно так.
		> add_dbg_obj sphere 1 1 1  
		(добавляем объект типа сфера с координатами (1,1,1) )
В С/С++ - все, что нужно, это написать ф-ю типа: 
		void add_obj(const char* name, float x, float y, float z);
И добавить команду в консоль парой строчек ( об этом ниже).

При такой постановке задачи, постает вопрос о том как осуществить автоматическую проверку правильности типов и количества параметров.
Так как команды могут иметь различное количество и типы параметров, а все что есть у консоли - это указатель на ф-ю.
Для решения данной задачи нам помогут шаблоны (templates). Если у кого-то на данном этапе (или раньше) возникли ассоциации с Lua Bind и
вы отлично себе представляете как это работает, то дальше мжно не читать. Хотя, скажу честно, в луабинд я никогда не смотрел, но мне кажется там использован похожий подход.

К стате, ниже я постараюсь показать как можно использовать, то о чем я пишу, для облегчения работы со скриптовыми языками (тем же Луа) если вы 
еще не используете решение типа Луабинд. Так как я сомневаюсь, что мое изобретение намного пробеманей чем уже зарекомендовавшая себя либа.
Однако, с точки зрения понимания работы данного подхода и взятия его на вооружение лдя каких-то своих наработок данная моя заметка может быть очень полезна. ИМХО :-)

Итак будем отталкиватся наверное от обратного, а именно я покажу интерфейс для создания команды:

	// создаем команду с именем, описанием и указателем на С/С++ ф-ю.
	// если мы ошибемся в параметрах, которые мы указываем для специализации шаблона,
	// то компилятор нам об этом даст знать :-) 
	BaseCmd* pcmd = new dconsole::IO_Cmd2<char*, int, int >("cmdname", "description", fpointer);
	// все команда создана, дольше ее можно использовать как саму по себе ( params - массив аргументов типа Variant - о нем ниже)
	pcmd->runCommand(params, dconsole::Instance());
	// так и зарегистрировать в консоли
	dconsole::Instance().registerCommand(pcmd);

Теперь, когда мы в консоли напишем: cmdname 2 4 - вызовется соответствующая команда, аргументы распарсятся и будут переданы в fpointer.
Если аргументы не будут строго соответствовать типу int, консоль попытается их конвертировать ( например 4.7 преобразуется в 4) и в положительном случае 
вызвать ф-ю. Если же аргументы сконвертировать в нужный тип не удается, или их количество не соответствует обозначенному, то будет
выведено соответствующее сообщение об ошибке. например:

	cmdname: bad arguments, usage: cmdname INT INT. ( usage тоже, как вы поняли, генерится автоматически).

Разберемся теперь с внутренним устройством класса IO_Cmd2 ( для различного кол-ва аргументов есть свой класс).
Но для начала рассмотрим общий интерфейс. Все классы команд IO_Cmd* наследуются от общего класса BaseCmd:

		class BaseCmd {
		public:
			// Variant class to represent command line parameters
			class Variant {
				// ...
			};

			template<typename T>
			class Type2String {
			public:
				MyString operator()();
				static MyString name();
			};

		protected:
			const MyString m_name;
			const MyString m_description;

			BaseCmd(const MyString& name, const MyString desc):
			m_name(name), m_description(desc)
			{
			}
			virtual bool checkArguments(const std::vector<BaseCmd::Variant>& params) = 0;

		public:
			const MyString getName() const { return m_name; }
			const MyString getDescription() const { return m_description; }
			virtual const MyString getUsage() const = 0;
			virtual bool runCommand(const std::vector<BaseCmd::Variant>& params, Console& console) = 0;
			virtual ~BaseCmd() {};

		};


Как видно каждая команда, имеет имя, описание, usage, и ф-ю checkArguments она и класс Variant представлют
наибольший интерес, так как их функционал используется для автоматической проверки и конвертации переданных параметров.

Рассмотрим поближе класс вариант:

 class Variant {
		// ... members, etc.

        MyString toString(const int i) const;
        MyString toString(const float f) const ;
        int toInt(const MyString& str) const ;
        float toFloat(const MyString& str) const ;
        bool toBool(const MyString& str) const ;
        
        static bool isOfTypeInt(const char *String);
        static bool isOfTypeFloat(const char *String);
        static bool isOfTypeBool(const char *String);
    public:
        
        // constructors
        explicit Variant(int i);
        explicit Variant(float f);
        explicit Variant(MyString str);

        // cast operators 
        operator int () const ;
        operator const char* () const ;
        operator bool () const ;
        //... other 

        // convertation checks
        template<typename T>  bool canBeConvertedTo() const; 
         // type check
        template<typename T> bool is() const { return canBeConvertedTo<T>(); }
    };
    
Как видно, у класса есть конструкторы для различных типов, ф-и проверки является ли значение, содержащееся в классе
действительно значением какого-либо типа и операторы преобразования к различным типам. Private ф-и нас пока не интересуют, они 
выполняют внетреннюю работу.

Моежет вы заметили, что в классе BaseCmd содержится утилирарный класс Type2String. Он помогает при выводе usage и специализируется примерно таким образом:

	// пример специализации для bool.
	template<> class BaseCmd::Type2String<bool> {
		public:
			static MyString name() { return MyString("BOOL"); } 
			static const int LEN = sizeof("STRING");
	};

Теперь, когда мы немного разобрались с классом BaseCmd, посмотрим на обещаную реализацию IO_Cmd2:

	template <typename R, typename T1, typename T2>
	class IO_Cmd2: public BaseCmd {
		// для облегчения работы
		typedef IO_Cmd2<R,T1, T2> Me_t;
		// об этом классе ниже
		friend class dconsole::doCmd2<Me_t, R, indexOf<StringType,R>::value!=-1 >;
	protected:
		typedef R (*FP_t)(T1, T2);
		typedef T1 firstParam_t;
		typedef T2 secondParam_t;
		typedef R returnValue_t;

		FP_t m_func_ptr;
	public:
		// FP_t - будем честными: что передали в template, то и в конструктор
		// таким образом, легко проверить правильность переданного указателя на ф-ю
		IO_Cmd2(const MyString& name, const MyString desc, FP_t fp):
		BaseCmd(name, desc)
		,m_func_ptr(fp)
		{
		}
		// консоль разбивает введенную строку по пробелам и составляет массив параметров params
		bool runCommand(const std::vector<BaseCmd::Variant>& params, Console& console)
		{
			if( !checkArguments(params) )
				return false;
			// об этом классе чуть ниже
			dconsole::doCmd2<Me_t, R, indexOf<StringType,R>::value !=-1 >::doCommand(m_func_ptr, params[0], params[1], console);
			return true;
		}
	protected:
		// дл ялюбой команды легоко создается ее usage с помощью Type2String
		const MyString getUsage() const
		{
			MyString str;
			MyString p1 = Type2String<T1>::name();
			MyString p2 = Type2String<T2>::name();
			str.append(getName());str.append(" ");
			str.append( p1 );str.append(" ");
			str.append( p2 );
			return str;
		}
	private:
		// класс Variant позволяет легко осуществить проверку правильности 
		// типов и количества параметров
		bool checkArguments(const std::vector<BaseCmd::Variant>& params)
		{
			if(params.size() != 2)
				return false;
			if( !params[0].is<T1>() || !params[1].is<T2>())
				return false;
			return true;
		}
	};
	
Как видно, основную работу по выполнению совершает класс doCmd2. В начале строка
	
	dconsole::doCmd2<Me_t, R, indexOf<StringType,R>::value !=-1 >::doCommand(m_func_ptr, params[0], params[1], console);
	
может показаться немного монстрообразной однако здесь нет ничего сложного:
структура indexOf параметризируется 2мя параметрами. Первый это обычно TypeList (см. Александреску), а второй - тип, который мы ищем в TypeList.
Таким образом, здесь мы ищем входит ли тип возвращаемого знаения (R он же returnValue_t) нашей ф-и в список типов которые являются троками.

Приведу здесь краткую реализацию структуры TypeList.

	template <class T, class U> 
	struct TypeList {
		typedef T Head;
		typedef U Tail;
	};
	
А тип StringType - это набор различных типов типа ( простите за каламбур :-) ) строка:

typedef TypeList<MyString, TypeList<char*, TypeList<const char*, NullType> > > StringType;

Все это делается для того, чтобы специализоровать по разному класс doCmd2 в зависимости от возвращеаемого значения - для строк одна реализациия, а не для строк - другая.
Вот так выглядит его обьявление:
	template <typename Cmd_t, typename rv, bool isStringType> class doCmd2;
На самом деле еще есть специализация для возвращаемого типа void. Так как мы неможем написать такое:
	rv retval = func_ptr(param1, param2);
если rv - это void.

Для более полной картины приведу специализацию для строковых типов:
// Cmd_t - класс команды IO_Cmd2 ( либо IO_Cmd1UD - об этом пожже)
template <typename Cmd_t, typename rv> class doCmd2<Cmd_t, rv, true> {
public:
    static void doCommand(typename Cmd_t::FP_t func_ptr, const typename Cmd_t::firstParam_t param1, const typename Cmd_t::secondParam_t param2, class Console& console) {
        MyString str = func_ptr(param1, param2); 
        console.addLogRecord(Console::COL_CMD_RESULT, str);
    }
};		

В строке типа: const typename Cmd_t::secondParam_t param2, слово typename необходимо, так как компилятор не может точно знать, что это тип, а может вполне предполагать, что это статическая переменная класса.
По-моему компилятор Visual C++ на это не ругается, но при переносе под PS3 было много проблем связанных с разными подобными вещами, так как Visual C++ 
вообще закрывает глаза на многие вещи, тем самым развращая программиста, в то время как gcc более придерживается стандарта, и при переносе кода, особенно такого как этот (содержащего много шаблонов) возникали определенные неудобства.

Выше я упомянул о классе IO_Cmd1UD - он позволяет создать команду передав в нее некое значение, которое будет использоватся при ее выполнении
	например:
		
		dconsole::BaseCmd* pcmd = new dconsole::IO_Cmd1UD<float, int, float>("int_floatUD", "desc1", f_intfloat, 2.35f);
таким образом это команда с одним параметром, хотя 	ф-я f_intfloat имеет сигнатуру: float (*)(int, float). Поэтому в ф-и runCommand мы все равно будем
использовать класс doCmd2. Но это уже детали.

Также мной были реализованы переменные консоли, которые можно устанавливать и считывать :-) Использовать как параметры консоли их пока нельзя.
Хотя дописать соответствующий функционал не составляет труда. Исходники открыты! :-)
Думаю это очевидно, но также можно реализовывать свои специфичные типы команд наследовав их от BaseCmd - если вам не хватает функционала.
Привер реализации есть в исходном коде.

Да, чуть на забыл подобный подход легко можно использовать, чтобы облегчить работу со скриптовыми языками, а именно при реализации ф-ий
Тоесть нам ненужно будет вручную в каждой ф-и вызывать tostring, toNumber и т.п. Нужно только соответственно изменить класс Variant.

Вот вроде бы и все. Незнаю насколько получилось доходчиво обьяснить все то, что я сделал. В любом случае исходный код доступен. А также есть примеры (текстовый, OpenGL и DirectX) использования косоли.
Таким образом даже не задумываясь о внутреннем устройстве можно с легкостью использовать данный функционал.

Спасибо!

P.S.ри написании этой заметки исправил парочку минорных ошибочек ;-)